# 动态规划
通常说，动态规划是将一个体量庞大的问题转化成解决很多的小步骤，每个步骤会产生一个决策点，

## DFS

### 回溯
对回溯的理解最具体的是走迷宫的问题：<br>
当走到一个死胡同的时候，我们考虑退到上一个分岔路口走另外一条路；<br>
当经过这个岔路口的所有道路都通向死胡同，我们会退到上一个岔路口；<br>
不断向上退到岔路口直到有一条路可以走出去。<br>
另外一个用于理解回溯的是数独问题：<br>
当填到一个空格的时候，发现不论填什么数字都会产生重复，我会回退到上一个有不止一个可能的填空处；<br>
当在这个空格选择另外一个备选数字，向下继续填，直到出现无解空格；<br>
不断回到之前做选择的空格处，直到数独填完。<br>
可以看出来这个回到上一个选择点的操作就成为`回溯`<br>
* 在走迷宫问题中，如果一个岔路口完全走不出去就可以被认为这个岔路口就是一个死胡同了，后续到达这个岔路口的路线不需要判断就可以直接pass，因此这个岔路口就可以记录为false
* 在数独问题中，如果一个空格
* 实际上数独问题就是一个升级版的八皇后问题
* 实际上回溯就是一种很典型的`DFS`思想，将每一种可能的结果进行枚举

### 记忆回溯
从上一部分最后的分析可以看出对回溯中一些部分及时止损是非常有必要的，这就是用一个新的数据结构的空间来为原问题进行及时止损，用空间复杂度换时间复杂度的方案<br>
因此说带记忆的回溯是一种优化后的算法。

#### 递归
递归很可能在多种算法中使用，在涉及回溯的算法中使用递归的思想是很常用的

## BFS

如果说回溯是把每一个可能的结果枚举出来的强迫症谋士，那么广度优先就是一个眼观六路耳听八方的未雨绸缪爱好者。<br>
广度优先似乎是一般大家更推崇的动态规划思想，至少在目前见到的leetcode题用广度优先的算法可以得到更好的效果。<br>
因此广度优先需要注意的点就值得一写。

### 状态和决策点
在很多讲解动态规划的博客中常见的两个专业词汇就是状态/状态转移和决策点。
其实可以说，一个状态不一定是一个决策点，因为存在一连串连贯状态而不需要在这其中进行决策判断。
但是如果将状态转移图简化，就会发现连续状态可以抽象成一个状态，这样的状态转移图才更加有意义。

### 思路
 > 1. 划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。
 > 2. 确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。
 > 3. 确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。
 > 4. 寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。

## Leetcode例题

### 264.丑数
#### 思路
  1. 划分阶段：将问题划分为，一定存在一个数a×2之后正好比当前的丑数大，b×3之后正好比当前的丑数大，c×5后正好比当前的丑数大，则选择a,b,c中最小数为下一个丑数。
  2. 确定状态和状态变量：每一个状态应该包括四个元素：
  * 当前丑数
  * ×2之后正好比当前的丑数大的a
  * ×3之后正好比当前的丑数大的b
  * ×5之后正好比当前的丑数大的c
  3. 确定决策并写出状态转移方程：决策即a,b,c中最小的数为新的丑数，a,b,c的索引后移，直到满足新的丑数下状态稳定，更新a,b,c的索引。
  4. 寻找边界条件：即第n个丑数，用一个数组记录每一个丑数直到数组大小为n。
  #### Java代码
  ```
  public int nthUglyNumber(int n) {
        int[] dp = new int[n]; 
            dp[0]=1;
            int index2=0; //此下标对应的数乘2刚好大于上一个丑数，此下标之前的数乘2都小于等于上一个丑数
            int index3=0; //类似上方，乘2变成乘3
            int index5=0; //类似上方，乘3变成乘5
            for(int i = 1; i < n; i++){
                dp[i] = Math.min(Math.min(dp[index2]*2, dp[index3]*3), dp[index5]*5);
                while(dp[index2]*2 <= dp[i]) ++index2;
                while(dp[index3]*3 <= dp[i]) ++index3;
                while(dp[index5]*5 <= dp[i]) ++index5;
            }
            return dp[n-1];
    }  
```

### 376.摆动序列
#### 思路
 + **首先是最简单的动态规划思路**
  1. 划分阶段：将原本的大问题分解成以每个数组中的元素结尾时的摆动序列长度，这里可以用**up**和**down**两种情况来描述，**up**代表以该元素上升的摆动序列最长的长度，**down**代表以该元素下降的摆动序列最长的长度。
  2. 确定状态和状态变量：状态即两个dp数组中分别用于记录`dp_up[]`和`dp_down[]`的数组元素。
  3. 确定决策并写出状态转移方程：决策是将`nums[i]`之前原数组中的每个元素`nums[j]`和`nums[i]`进行比较，更新up和down的数值。具体思路是已知前一个`dp_up[j]`记录的是到`nums[j]`时上升的摇摆序列长度，若`nums[j] > nums[i]`则此时到`nums[i]`时是下降的摆动序列，因此将`dp_down[]`更新为`dp_down[] = dp_up[j] + 1`，值得注意的是因为最后dp数组中保留的都是最大数值，因此需要在更新的时候取与已有`dp_down[i]`比较后的较大值；`dp_up[]`更新方式类似。因此最后遍历nums数组之后就可以得到完整的`dp_up[]`和`dp_down[]`。
  
+ **线性动态规划算法**

>数组中的任何元素都对应下面三种可能状态中的一种：

>上升的位置，意味着 nums[i] > nums[i - 1]nums[i]>nums[i−1]
>下降的位置，意味着 nums[i] < nums[i - 1]nums[i]<nums[i−1]
>相同的位置，意味着 nums[i] == nums[i - 1]nums[i]==nums[i−1]
>更新的过程如下：

>如果 nums[i] > nums[i-1]nums[i]>nums[i−1] ，意味着这里在摆动上升，前一个数字肯定处于下降的位置。所以 up[i] = down[i-1] + 1up[i]=down[i−1]+1 ， down[i]down[i] 与 down[i-1]down[i−1] 保持相同。

>如果 nums[i] < nums[i-1]nums[i]<nums[i−1] ，意味着这里在摆动下降，前一个数字肯定处于下降的位置。所以 down[i] = up[i-1] + 1down[i]=up[i−1]+1 ， up[i]up[i] 与 up[i-1]up[i−1] 保持不变。

>如果 nums[i] == nums[i-1]nums[i]==nums[i−1] ，意味着这个元素不会改变任何东西因为它没有摆动。所以 down[i]down[i] 与 up[i]up[i] 与 down[i-1]down[i−1] 和 up[i-1]up[i−1] 都分别保持不变。

>最后，我们可以将 up[length-1]up[length−1] 和 down[length-1]down[length−1] 中的较大值作为问题的答案，其中 lengthlength 是给定数组中的元素数目。

#### Java代码
```
    public int wiggleMaxLength(int[] nums) {
        if (nums.length < 2)
            return nums.length;
        int[] up = new int[nums.length];
        int[] down = new int[nums.length];
        up[0] = down[0] = 1;
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] > nums[i - 1]) {
                up[i] = down[i - 1] + 1;
                down[i] = down[i - 1];
            } else if (nums[i] < nums[i - 1]) {
                down[i] = up[i - 1] + 1;
                up[i] = up[i - 1];
            } else {
                down[i] = down[i - 1];
                up[i] = up[i - 1];
            }
        }
        return Math.max(down[nums.length - 1], up[nums.length - 1]);
    }
```
